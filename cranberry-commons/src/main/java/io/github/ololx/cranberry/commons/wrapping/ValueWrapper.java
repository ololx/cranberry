/**
 * Copyright 2022 the project cranberry authors
 * and the original author or authors annotated by {@author}
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.ololx.cranberry.commons.wrapping;

import java.io.Serializable;
import java.util.Arrays;
import java.util.stream.Collectors;

/**
 * The type ValueWrapper.
 *
 * project cranberry
 * created 2022-01-02 13:40
 *
 * @author Alexander A. Kropotin
 *
 * This stores the value {@link #getValue()}, value type {@link #getType() runtime type}
 * and value hash code {@link #toString()}.
 *
 * This allows to get a value string representation {@link #getValueStringRepresentation()}
 *
 * The {@link #toString()} method returns the string representation of the
 * value along with its type and identity hash code.
 *
 * project cranberry
 * created 2020-04-16 12:45
 *
 * @author Alexander A. Kropotin
 */
public final class ValueWrapper implements Serializable {

    /**
     * Use serialVersionUID for interoperability
     */
    private static final long serialVersionUID = -309177L;

    /**
     * The wrapped value hash code; see {@link #toString()}.
     *
     * @serial
     */
    private final int valueHashCode;

    /**
     * The wrapped value type; see {@link #toString()}, {@link #getType()}.
     *
     * @serial
     */
    private final Class<?> type;

    /**
     * The wrapped value; see {@link #getValueStringRepresentation()},
     * {@link #getValue()}, {@link #toString()}, {@link #getType()}.
     *
     * @serial
     */
    private final Object value;

    /**
     * The factory method for the getting a new {@code ValueWrapper} instance
     * for the supplied {@code value}.
     *
     * This method will return a new {@code ValueWrapper} instance for a given value
     * suitable for all {@code values} if the value is not an instance of a wrapper.
     * Otherwise, if the supplied {@code value} is already a {@link ValueWrapper} instance,
     * this method will return it as is.
     *
     * @param value the value to wrap; may be {@code null}
     * @return a wrapper for the supplied value; never {@code null}
     */
    public static ValueWrapper getInstance(Object value) {
        if (value instanceof ValueWrapper)
            return (ValueWrapper) value;

        return new ValueWrapper(value);
    }

    /**
     * Returns the string representation of a value for the supplied {@code value}
     * via the supplied custom {@code nullStringRepresentation}.
     *
     * If the supplied {@code value} is {@code null}, this method will return a
     * custom representation of the value from the {@code nullStringRepresentation}.
     * If the supplied {@code value} is not {@code null}, this method will return a string representation
     * which is generated by invoking {@link String#valueOf(Object) String.valueOf(value)}:
     * <ul>
     *     <li>
     *         for an each element of an array - if the value type is
     *         an array type; see {@link Class#isArray()};
     *     </li>
     *     <li>
     *         for the value - in another cases.
     *     </li>
     * </ul>
     *
     * @param value the value to wrap; may be {@code null}
     * @param nullStringRepresentation a custom representation of the value; is used by default
     * when value is {@code null}.
     * @return a string representation for the supplied value; never {@code null}
     */
    public static String getValueStringRepresentation(Object value, String nullStringRepresentation) {
        if (value == null)
            return String.valueOf(nullStringRepresentation);

        if (value.getClass().isArray())
            return String.format(
                    "[%s]",
                    Arrays.stream((Object[]) value)
                            .map(element -> String.valueOf(element))
                            .collect(Collectors.joining(", "))
            );

        return String.valueOf(value);
    }

    /**
     * Constructs an {@code ValueWrapper} with the
     * specified value, value type and value hash code.
     *
     * @param value the value to wrap; may be {@code null}.
     */
    private ValueWrapper(Object value) {
        this.value = value;
        this.valueHashCode = value == null
                ? 0
                : value.hashCode();
        this.type = value == null
                ? null
                : value.getClass();
    }

    /**
     * Returns the origin value supplied to {@link #ValueWrapper(Object)} or
     * {@code null} if the value is {@code null}.
     *
     * @return an origin value with type {@code Object}.
     */
    public Object getValue() {
        return this.value;
    }

    /**
     * Returns the origin value type supplied to {@link #ValueWrapper(Object)} or
     * {@code null} if the value is {@code null}.
     *
     * @return a origin value type with type {@code Class<?>}.
     */
    public Class<?> getType() {
        return this.type;
    }

    /**
     * Returns the string representation of a wrapped value.
     * This method returns wrapped value string representation by invoking
     * {@link #getValueStringRepresentation(Object value, String nullStringRepresentation)
     * ValueWrapper.getValueStringRepresentation(this.getValue(), null)}.
     *
     * If the wrapped {@code value} is {@code null}, this method will return a
     * string `{@code null}'.
     *
     * @return a string representation for the wrapper value; never {@code null}
     */
    public String getValueStringRepresentation() {
        return ValueWrapper.getValueStringRepresentation(this.getValue(), null);
    }

    /**
     * Indicates whether the wrapped value is defined or not.
     *
     * @return {@code true} if the wrapped value is not null;
     * {@code false} otherwise.
     */
    public boolean isValueDefined() {
        return this.getValue() != null;
    }

    /**
     * Indicates whether the wrapped value is undefined or
     * it is defined.
     *
     * @return {@code true} if the wrapped value is null;
     * {@code false} otherwise.
     */
    public boolean isValueUndefined() {
        return !this.isValueDefined();
    }

    /**
     * Indicates whether the wrapped value type is defined or not.
     *
     * @return {@code true} if the wrapped value type is not null;
     * {@code false} otherwise.
     */
    public boolean isTypeDefined() {
        return this.getType() != null;
    }

    /**
     * Indicates whether the wrapped value type is undefined
     * or it is defined.
     *
     * @return {@code true} if the wrapped value type is null;
     * {@code false} otherwise.
     */
    public boolean isTypeUndefined() {
        return !this.isTypeDefined();
    }

    /**
     * Returns a hash code value for the object. This method is
     * supported for the benefit of hash tables such as those provided by
     * {@link java.util.HashMap}, {@link java.util.HashSet}.
     *
     * @return  a hash code value for this object.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @see     java.lang.System#identityHashCode
     */
    @Override
    public int hashCode() {
        final int prime = 31;

        int result = 1;
        result = prime * result + valueHashCode;
        result = prime * result + ((this.value == null) ? 0 : this.value.hashCode());
        result = prime * result + ((this.type == null) ? 0 : this.type.hashCode());

        return result;
    }

    /**
     * Indicates whether some other object is "equal to" this one.
     *
     * @param   obj   the reference object with which to compare.
     * @return  {@code true} if this object is the same as the obj
     *          argument; {@code false} otherwise.
     * @see     #hashCode()
     * @see     java.util.HashMap
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (!(obj instanceof ValueWrapper)) {
            return false;
        }

        ValueWrapper other = (ValueWrapper) obj;

        boolean isValueHashCodeEquals = this.valueHashCode == other.valueHashCode;

        boolean isValueEquals = false;
        if (this.value == null || other.value == null) {
            if (this.value == null && other.value == null) {
                isValueEquals = true;
            }
        } else {
            isValueEquals = this.value.equals(other.value);
        }

        boolean isTypeEquals = false;
        if (this.type == null || other.type == null) {
            if (this.type == null && other.type == null) {
                isTypeEquals = true;
            }
        } else {
            isTypeEquals = this.type.equals(other.type);
        }

        return isValueHashCodeEquals & isValueEquals && isTypeEquals;
    }

    /**
     * Returns the string representation of a value along with its type and
     * identity hash code.
     *
     * The {@code toString} method for this class returns a string consisting of:
     * <ul>
     *     <li>
     *         the string representation of the origin value - if the origin value is null;
     *
     *         for instance:
     *         <blockquote>
     *             <pre>
     *                 value.getValueStringRepresentation()
     *             </pre>
     *         </blockquote>
     *     </li>
     *     <li>
     *         the name of the class of which the origin value object is an instance,
     *         the at-sign character `{@code @}', the unsigned hexadecimal representation
     *         of the hash code of the origin value object, the at-sign character `{@code =}'
     *         and the string representation of the origin value - if the origin value is null.
     *
     *         for instance:
     *         <blockquote>
     *             <pre>
     *                 '[' + getClass().getName() + '@' + Integer.toHexString(value.hashCode()) + ']'
     *                 + '=' + value.getValueStringRepresentation()
     *             </pre>
     *         </blockquote>
     *     </li>
     * </ul>
     *
     * @return a string representation of the object.
     */
    @Override
    public String toString() {
        return this.isTypeDefined()
                ? String.format(
                "[%s@%s]=%s",
                this.getType().getName(),
                Integer.toHexString(this.valueHashCode),
                this.getValueStringRepresentation()
        )
                : this.getValueStringRepresentation();
    }
}
