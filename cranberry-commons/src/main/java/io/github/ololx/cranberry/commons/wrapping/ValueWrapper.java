/**
 * Copyright 2022 the project cranberry authors
 * and the original author or authors annotated by {@author}
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.ololx.cranberry.commons.wrapping;

import java.io.Serializable;
import java.util.Arrays;

/**
 * The type ValueWrapper.
 *
 * project cranberry
 * created 2022-01-02 13:40
 *
 * @author Alexander A. Kropotin
 *
 * This stores the value {@link #getValue()}, value type {@link #getType() runtime type}
 * and value hash code {@link #toString()}.
 *
 * This allows to get a value string representation {@link #getValueStringRepresentation()}
 *
 * The {@link #toString()} method returns the string representation of the
 * value along with its type and identity hash code.
 *
 * project cranberry
 * created 2020-04-16 12:45
 *
 * @author Alexander A. Kropotin
 */
public final class ValueWrapper implements Serializable {

    /**
     * Use serialVersionUID for interoperability
     */
    private static final long serialVersionUID = -309177L;

    /**
     * The wrapped value type; see {@link #toString()}, {@link #getType()}.
     *
     * @serial
     */
    private final Class<?> type;

    /**
     * The wrapped value; see {@link #getValueStringRepresentation()},
     * {@link #getValue()}, {@link #toString()}, {@link #getType()}.
     *
     * @serial
     */
    private final Object value;

    /**
     * The factory method for the getting a new {@code ValueWrapper} instance
     * for the supplied {@code value}.
     *
     * This method will return a new {@code ValueWrapper} instance for a given value
     * suitable for all {@code values} if the value is not an instance of a wrapper.
     * Otherwise, if the supplied {@code value} is already a {@link ValueWrapper} instance,
     * this method will return it as is.
     *
     * @param value the value to wrap; may be {@code null}
     * @return a wrapper for the supplied value; never {@code null}
     */
    public static ValueWrapper getInstance(Object value) {
        if (value instanceof ValueWrapper)
            return (ValueWrapper) value;

        return new ValueWrapper(value);
    }

    /**
     * Returns the string representation of a value for the supplied {@code value}
     * via the supplied custom {@code nullStringRepresentation}.
     *
     * If the supplied {@code value} is {@code null}, this method will return a
     * custom representation of the value from the {@code nullStringRepresentation}.
     * If the supplied {@code value} is not {@code null}, this method will return a string representation
     * which is generated by invoking {@link String#valueOf(Object) String.valueOf(value)}:
     * <ul>
     *     <li>
     *         for an each element of an array - if the value type is
     *         an array type; see {@link Class#isArray()};
     *     </li>
     *     <li>
     *         for the value - in another cases.
     *     </li>
     * </ul>
     *
     * @param value the value to wrap; may be {@code null}
     * @return a string representation for the supplied value; never {@code null}
     */
    public static String getValueStringRepresentation(Object value) {
        return getValueStringRepresentation(value, "null");
    }

    /**
     * Returns the string representation of a value for the supplied {@code value}
     * via the supplied custom {@code nullStringRepresentation}.
     *
     * If the supplied {@code value} is {@code null}, this method will return a
     * custom representation of the value from the {@code nullStringRepresentation}.
     * If the supplied {@code value} is not {@code null}, this method will return a string representation
     * which is generated by invoking {@link String#valueOf(Object) String.valueOf(value)}:
     * <ul>
     *     <li>
     *         for an each element of an array - if the value type is
     *         an array type; see {@link Class#isArray()};
     *     </li>
     *     <li>
     *         for the value - in another cases.
     *     </li>
     * </ul>
     *
     * @param value the value to wrap; may be {@code null}
     * @param nullStringRepresentation a custom representation of the value; is used by default
     * when value is {@code null}.
     * @return a string representation for the supplied value; never {@code null}
     */
    public static String getValueStringRepresentation(Object value, String nullStringRepresentation) {
        if (value == null) {
            return String.valueOf(nullStringRepresentation);
        }

        Class<?> type = value.getClass();
        if (!type.isArray()) {
            return String.valueOf(value);
        }

        Class<?> componentType = type.getComponentType();
        if (!componentType.isPrimitive()) {
            return Arrays.toString((Object[]) value);
        }

        switch (componentType.getName()) {
            case "int":
                return Arrays.toString((int[]) value);
            case "char":
                return Arrays.toString((char[]) value);
            case "byte":
                return Arrays.toString((byte[]) value);
            case "long":
                return Arrays.toString((long[]) value);
            case "short":
                return Arrays.toString((short[]) value);
            case "float":
                return Arrays.toString((float[]) value);
            case "double":
                return Arrays.toString((double[]) value);
            case "boolean":
                return Arrays.toString((boolean[]) value);
            default:
                throw new IllegalArgumentException("Unknown primitive type: " + componentType.getName());
        }
    }

    /**
     * Constructs an {@code ValueWrapper} with the
     * specified value, value type and value hash code.
     *
     * @param value the value to wrap; may be {@code null}.
     */
    private ValueWrapper(Object value) {
        this.value = value;
        this.type = value == null ? Object.class : value.getClass();
    }

    /**
     * Returns the origin value supplied to {@link #ValueWrapper(Object)} or
     * {@code null} if the value is {@code null}.
     *
     * @return an origin value with type {@code Object}.
     */
    public Object getValue() {
        return this.value;
    }

    /**
     * Returns the origin value type supplied to {@link #ValueWrapper(Object)} or
     * {@code null} if the value is {@code null}.
     *
     * @return a origin value type with type {@code Class<?>}.
     */
    public Class<?> getType() {
        return this.type;
    }

    /**
     * Returns the string representation of a wrapped value.
     * This method returns wrapped value string representation by invoking
     * {@link #getValueStringRepresentation(Object value, String nullStringRepresentation)
     * ValueWrapper.getValueStringRepresentation(this.getValue(), null)}.
     *
     * If the wrapped {@code value} is {@code null}, this method will return a
     * string `{@code null}'.
     *
     * @return a string representation for the wrapper value; never {@code null}
     */
    public String getValueStringRepresentation() {
        return getValueStringRepresentation(this.value);
    }

    /**
     * Indicates whether the wrapped value is defined or not.
     *
     * @return {@code true} if the wrapped value is not null;
     * {@code false} otherwise.
     */
    public boolean isEmpty() {
        return this.getValue() != null;
    }

    /**
     * Indicates whether the wrapped value is undefined or
     * it is defined.
     *
     * @return {@code true} if the wrapped value is null;
     * {@code false} otherwise.
     */
    public boolean isPresent() {
        return !this.isEmpty();
    }

    /**
     * Returns a hash code value for the object. This method is
     * supported for the benefit of hash tables such as those provided by
     * {@link java.util.HashMap}, {@link java.util.HashSet}.
     *
     * @return  a hash code value for this object.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @see     java.lang.System#identityHashCode
     */
    @Override
    public int hashCode() {
        final int prime = 31;

        int result = 1;
        result = prime * result + valueHashCode();
        result = prime * result + this.type.hashCode();

        return result;
    }

    /**
     * Returns a hash code value for the value object.
     *
     * @return  a hash code value for the value object.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @see     java.lang.System#identityHashCode
     */
    private int valueHashCode() {
        if (this.value == null) {
            return 0;
        }

        if (!this.type.isArray()) {
            return this.value.hashCode();
        }

        Class<?> componentType = this.type.getComponentType();
        if (!componentType.isPrimitive()) {
            return Arrays.hashCode((Object[]) this.value);
        }

        switch (componentType.getName()) {
            case "int":
                return Arrays.hashCode((int[]) this.value);
            case "char":
                return Arrays.hashCode((char[]) this.value);
            case "byte":
                return Arrays.hashCode((byte[]) this.value);
            case "long":
                return Arrays.hashCode((long[]) this.value);
            case "short":
                return Arrays.hashCode((short[]) this.value);
            case "float":
                return Arrays.hashCode((float[]) this.value);
            case "double":
                return Arrays.hashCode((double[]) this.value);
            case "boolean":
                return Arrays.hashCode((boolean[]) this.value);
            default:
                throw new IllegalArgumentException("Unknown primitive type: " + componentType.getName());
        }
    }

    /**
     * Indicates whether some other object is "equal to" this one.
     *
     * @param   obj   the reference object with which to compare.
     * @return  {@code true} if this object is the same as the obj
     *          argument; {@code false} otherwise.
     * @see     #hashCode()
     * @see     java.util.HashMap
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (!(obj instanceof ValueWrapper)) {
            return false;
        }

        ValueWrapper other = (ValueWrapper) obj;

        boolean isValueEquals = false;
        if (this.value == null || other.value == null) {
            if (this.value == null && other.value == null) {
                isValueEquals = true;
            }
        } else {
            isValueEquals = this.value.equals(other.value);
        }

        boolean isTypeEquals = this.type.equals(other.type);

        return isValueEquals && isTypeEquals;
    }

    /**
     * Returns the string representation of a value along with its type and
     * identity hash code.
     *
     * The {@code toString} method for this class returns a string consisting of follows: the name of the class of
     * which
     * the origin value object is an instance, the at-sign character `{@code @}', the unsigned hexadecimal
     * representation of the hash code of the origin value object, the at-sign character `{@code =}' and the string
     * representation of the origin value - if the origin value is null. For instance:
     * <blockquote>
     * <pre>
     * '[' + getClass().getName() + '@'
     * + Integer.toHexString(value.hashCode()) + ']'
     * + '=' + value.getValueStringRepresentation()
     * </pre>
     * </blockquote>
     *
     * @return a string representation of the object.
     */
    @Override
    public String toString() {
        return String.format(
            "[%s@%s]=%s",
            this.getType().getName(),
            Integer.toHexString(this.valueHashCode()),
            this.getValueStringRepresentation()
        );
    }
}
